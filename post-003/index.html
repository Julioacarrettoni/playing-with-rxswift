<!DOCTYPE html>
<html>

<head>
    
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">

    <!-- Enable responsiveness on mobile devices-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

    <title>
        
    </title>

    

<link id="darkly" class="stylesheet" rel="stylesheet"
    href="https:&#x2F;&#x2F;julioacarrettoni.github.io&#x2F;playing-with-rxswift&#x2F;darkly.css" />


    <!-- This script must follow css -->
    
    <script type="text/javascript" src="https:&#x2F;&#x2F;julioacarrettoni.github.io&#x2F;playing-with-rxswift&#x2F;js&#x2F;zulma_switchcss.js"></script>
    

    

    
    <script defer type="text/javascript" src="https:&#x2F;&#x2F;julioacarrettoni.github.io&#x2F;playing-with-rxswift&#x2F;elasticlunr.min.js"></script>
    <script defer type="text/javascript" src="https:&#x2F;&#x2F;julioacarrettoni.github.io&#x2F;playing-with-rxswift&#x2F;search_index.en.js"></script>
    

    
    

    <noscript>
        <style>
            .navbar-menu {
                display: block;
            }

            .js-only {
                display: none;
            }
        </style>
    </noscript>
    
</head>

<body>
    
    
<!-- START NAV -->


    

<header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-brand">
                
                <a class="navbar-item" href="/playing-with-rxswift">
                    
                    <span>Playing with RxSwift</span>
                    
                </a>
                
                <span class="navbar-burger burger" data-target="navbarMenu">
                    <span></span>
                    <span></span>
                    <span></span>
                </span>
            </div>
            <div id="navbarMenu" class="navbar-menu">
                <div class="navbar-end">
                    

                    
                    <div class="navbar-item search-container js-only">
                        <input class="input" id="search" type="search" placeholder="Search">

                        <div class="search-results box">
                            <div class="search-results__items"></div>
                        </div>
                    </div>
                    
                </div>
            </div>
        </div>
    </nav>
</header>


    

<!-- END NAV -->
<main>
    <section class="container">
        <div class="columns is-desktop">
            <div class="column is-10-desktop is-offset-1-desktop">
                <article itemscope itemtype="http://schema.org/BlogPosting">
                    <div class="card article">
                        <div class="card-content">
                            
<header>
    <div class="has-text-centered">
        <a href="https://julioacarrettoni.github.io/playing-with-rxswift/post-003/">
            <p class="title article-title">3. The feature request
            </p>
        </a>
        <div class="tags has-addons level-item">
            <span class="tag is-rounded">2020-05-03</span>
                       
            <span class="tag is-rounded">
<svg class="i-clock" viewBox="0 0 32 32" width="16" height="16" fill="none" stroke="currentcolor" stroke-linecap="round"
    stroke-linejoin="round" stroke-width="6.25%">
    <circle cx="16" cy="16" r="14" />
    <path d="M16 8 L16 16 20 20" />
</svg>
<span>&nbsp;17 minute read</span>
</span>
        </div>
    </div>
</header>

                            <div itemprop="articleBody" class="content article-body">
                                <p>Just as the changes were ready to be merged, a feature request comes in, can the existing code handle changes properly? Is the current strategy for polling strong enough?</p>
<p><strong><a href="https://julioacarrettoni.github.io/playing-with-rxswift/post-003/#skip_intro">Skip intro</a></strong></p>
<span id="continue-reading"></span><h1 id="story">Background story</h1>
<p>You were ready to request other engineers to review your humble pull request. Still, out of nowhere, a product manager approaches you with concern: Most of the employees using this app are not going to be in the warehouse. When in the warehouse, they can access the legacy system on their computers. Furthermore, warehouses don't have good Wi-Fi coverage anyway.</p>
<p>This product manager wants to bump a feature from milestone 3 into the MVP, the ability to switch between auto-polling and manual refresh.<br />
Of course, without the features introduced on milestones 1 and 2, this feature doesn't make too much sense. There is no settings page, plus there is no network request queue mechanism, and there is no login/logout, so you complain that the original ticket is not appropriate.<br />
The product manager creates a new ticket, and with the help from a senior designer, in a couple of minutes, they have something that should be <em>good enough</em> <sup><a href="https://julioacarrettoni.github.io/playing-with-rxswift/post-003/#1">1</a></sup>. However, without a proper analysis, we are bound to have some questions down the implementation road.<br />
You can complain that changing the plan is a bad idea, and is ok to raise concerns to question if these changes are worth the trouble, but at the end of the day, that's what the agile manifesto is all about<sup><a href="https://julioacarrettoni.github.io/playing-with-rxswift/post-003/#2">2</a></sup>. </p>
<p>The new requirements are:</p>
<ul>
<li>Show a toggle at the bottom of the map to turn auto-polling ON/OFF.</li>
<li>When auto polling is OFF, a &quot;refresh&quot; button should be visible.</li>
<li>The &quot;refresh&quot; button fires a network request to get the latest state of the system but does not enable auto-polling.</li>
</ul>
<p>A coworker recommends creating a PR for the current changes we already have. At the same time, branch out from it and start working on our new feature. This way, we can avoid creating a hella of a big PR with too many changes at once.</p>
<p>As a reminder, all PRs have to:</p>
<ol>
<li>Considers edge cases and non-happy paths</li>
<li>Handle errors</li>
<li>Introduces new unit tests</li>
</ol>
<table><thead><tr><th></th></tr></thead><tbody>
</tbody></table>
<h1 id="skip_intro">Work</h1>
<h3 id="goal">Goal</h3>
<p>Add a new feature into the MVP, a toggle to control auto-polling and a &quot;refresh&quot; button to refresh the system state manually:</p>
<ul>
<li>Show a toggle at the bottom of the map to turn auto-polling ON/OFF.</li>
<li>When auto polling is OFF, a &quot;refresh&quot; button should be visible.</li>
<li>The &quot;refresh&quot; button fires a network request to get the latest state of the system but does not enable auto-polling. </li>
</ul>
<p>Comply with the pull request requirements:</p>
<ol>
<li>Considers edge cases and non-happy paths</li>
<li>Handle errors</li>
<li>Introduces new unit tests</li>
</ol>
<h3 id="code">Code</h3>
<p>You need Xcode 11.4 or newer.</p>
<p>You can download the sample apps from <a href="https://github.com/Julioacarrettoni/playing-with-rxswift/tree/master/003">here</a>, you should start working on the <em>before</em> folder. In the end, it should look like the <em>after</em> folder.</p>
<p> <br />
 <br />
 </p>
<h4 id="ui-changes">UI changes</h4>
<p>The usual disclaimer applies here, as this blog is not focused on SwiftUI, all the work done in that area is minimal and with a naive approach in mind.<br />
For this reason, on the <code>Before</code> project, you can find that the UI changes already implemented, a very naive way.</p>
<div align="center"><img src="../003_auto_polling_on.png" alt="Bottom section of the iPhone simulator showing a toggle with the legend 'Auto Polling' on the on position" height="125" width="320" style="margin:16px"><img src="../003_auto_polling_off.png" alt="Bottom section of the iPhone simulator showing a simple text-button with the title 'refresh' and toggle with the legend 'Auto Polling' on the off position" height="125" width="320" style="margin:16px"></div>
<p>If we wanted to be super technical these are the changes:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;"> struct ContentView: View {
     @State var globalState: GlobalState? = nil
</span><span style="color:#a3be8c;">+    @State var isAutoPolling: Bool = false
+    
</span><span style="color:#c0c5ce;">     let disposeBag = DisposeBag()
     
     var body: some View {
</span><span style="color:#bf616a;">-        MapView(globalState: self.globalState)
-            .edgesIgnoringSafeArea(.all)
-            .onAppear(perform: self.refreshData)
</span><span style="color:#a3be8c;">+        VStack {
+            MapView(globalState: self.globalState)
+            VStack {
+                if !self.isAutoPolling {
+                    Button(action: {
+                        #warning(&quot;Missing implementation&quot;)
+                    }) { Text(&quot;Refresh&quot;) }
+                }
+                Toggle(isOn: self.$isAutoPolling, label: { Text(&quot;Auto Polling&quot;) })
+            }
+            .padding(.horizontal, 16)
+            .padding(.bottom, 16)
+        }
+        .edgesIgnoringSafeArea(.horizontal)
+        .edgesIgnoringSafeArea(.top)
</span><span style="color:#c0c5ce;">     }
</span></pre>
<p>In the real world, given how the ticket was rushed and the lack of specifications, the proper thing to do would be to set a meeting later in the development process to spend some time with the designer 1:1 to pimp this UI up.</p>
<p>A new <code>Bool</code> state was added to track the state of the toggle, <code>isAutoPolling</code>. Given the value of this boolean, the Button is added or removed from the UI (just changing its opacity is not good enough, you can try yourself). Then a couple of padding was added to make it look less horrible, and the  <code>edgesIgnoringSafeArea</code> was split to remove <code>.bottom</code> and avoid or toggle from getting behind the &quot;home bar&quot; on iOS.</p>
<p>The first thing we can do is fix the warning in the &quot;refresh&quot; button by calling <code>self.refreshData()</code>:</p>
<pre style="background-color:#2b303b;">
<span style="color:#ebcb8b;">Button</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">action</span><span style="color:#c0c5ce;">: {
    </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.refreshData()
}) { </span><span style="color:#ebcb8b;">Text</span><span style="color:#c0c5ce;">(</span><span style="color:#a3be8c;">&quot;Refresh&quot;</span><span style="color:#c0c5ce;">) }
</span></pre>
<p>But doing this has a side effect, as soon as we call <code>refreshData()</code> the system starts auto polling, to prevent that we can change the method implementation to only keep calling itself if <code>isAutoPolling</code> is on. </p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">   .subscribe(onSuccess: { globalState in
       self.globalState = globalState
</span><span style="color:#bf616a;">-      self.refreshData()
</span><span style="color:#a3be8c;">+      if self.isAutoPolling {
+          self.refreshData()
+      }
</span><span style="color:#c0c5ce;">   }, onError: { error in
</span><span style="color:#bf616a;">-      self.refreshData()
</span><span style="color:#a3be8c;">+      if self.isAutoPolling {
+          self.refreshData()
+      }
</span><span style="color:#c0c5ce;">   })

</span></pre>
<p>The only missing part here is that when we set <code>isAutoPolling</code> to true, nothing calls  <code>refreshData()</code>. To achieve that we could try to leverage <code>didSet</code> on the var itself like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#bf616a;">-    @State var isAutoPolling: Bool = false
</span><span style="color:#a3be8c;">+    @State var isAutoPolling: Bool = false {
+        didSet {
+            if self.isAutoPolling {
+                self.refreshData()
+            }
+        }
+    }
</span></pre>
<p>As I said, &quot;<em>try</em>&quot; you can already imagine this fails. The problem is the automatic biding provided by the <code>$</code> sugar syntax from <code>@state: propertyWrapper</code>. It doesn't trigger <code>didSet</code>.<br />
One alternative is to wrap the state in an <code>ObservableObject</code>. I'll go with option B because I'm lazy, the usual disclaimer applies here: &quot;<em>This is not a SwiftUI blog blah blah blah</em>&quot;, so maybe don't do this on your real apps without consulting some expert in the matter. Anyway, my solution is to provide a custom instance of <a href="https://developer.apple.com/documentation/swiftui/binding">Binding</a> by using the <a href="https://developer.apple.com/documentation/swiftui/binding/3363053-init">init that takes a get and set closure</a>.</p>
<pre style="background-color:#2b303b;">
<span style="color:#ebcb8b;">Toggle</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">isOn</span><span style="color:#c0c5ce;">: </span><span style="color:#ebcb8b;">Binding</span><span style="color:#c0c5ce;">(</span><span style="color:#b48ead;">get</span><span style="color:#c0c5ce;">: {
    </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.isAutoPolling
}, </span><span style="color:#b48ead;">set</span><span style="color:#c0c5ce;">: {
    </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.isAutoPolling = $</span><span style="color:#d08770;">0</span><span style="color:#c0c5ce;">
}), </span><span style="color:#bf616a;">label</span><span style="color:#c0c5ce;">: { </span><span style="color:#ebcb8b;">Text</span><span style="color:#c0c5ce;">(</span><span style="color:#a3be8c;">&quot;Auto Polling&quot;</span><span style="color:#c0c5ce;">) })
</span></pre>
<p>We could just call directly <code>self.refreshData()</code> here, but I think keeping it on the <code>didSet</code> and this binding as simple as possible is better. (opinion, not fact).</p>
<p>If you rerun the app, you will see that it works, at least half of the time (because we still have that code that makes 50% of the request fail). Even if we don't want to focus too much on usability to keep the post simple and focused, we still need to cover the following 3 points before we can create our fictitious pull request:</p>
<ol>
<li><a href="https://julioacarrettoni.github.io/playing-with-rxswift/post-003/#pr_req_1">Considers edge cases and non-happy paths.</a></li>
<li><a href="https://julioacarrettoni.github.io/playing-with-rxswift/post-003/#pr_req_2">Handle errors.</a></li>
<li><a href="https://julioacarrettoni.github.io/playing-with-rxswift/post-003/#pr_req_3">Introduces new unit tests.</a></li>
</ol>
<p> <br />
 <br />
 </p>
<h4 id="pr_req_1">1. Considers edge cases and non-happy paths.</h4>
<p>As we still have the <a href="https://github.com/Julioacarrettoni/playing-with-rxswift/blob/master/003/Before/RxPlaying/Services/Service.swift#L10-L17">overrideNetworkMock()</a> method from the previous post we can run the app and see how it would look like in a scenario were every other network request fails.<br />
For the auto-polling feature, this is not a big deal because we are automatically retrying on the <code>onError</code> closure from the subscribe Rx operator (<a href="https://github.com/Julioacarrettoni/playing-with-rxswift/blob/master/003/Before/RxPlaying/Views/ContentView.swift#L24">here</a>), but that's not the case for the manual refresh.</p>
<p>Normally any network stack has built-in &quot;retry&quot; and &quot;timeout&quot;, but this is not the case with our <code>FakeService</code>, so we are going to implement the retry at the application level using the <a href="https://github.com/ReactiveX/RxSwift/blob/c1bd31b397d87a54467af4161dde9d6b27720c19/RxSwift/Traits/PrimitiveSequence.swift#L157">retry</a> operator:</p>
<pre style="background-color:#2b303b;">
<span style="color:#65737e;">/**
     If the initial subscription to the observable sequence emits an error event, try repeating it up to the specified number of attempts (inclusive of the initial attempt) or until it succeeds. For example, if you want to retry a sequence once upon failure, you should use retry(2) (once for the initial attempt, and once for the retry).
     - see also: [retry operator on reactivex.io](http://reactivex.io/documentation/operators/retry.html)
     - parameter maxAttemptCount: Maximum number of times to attempt the sequence subscription.
     - returns: An observable sequence producing the elements of the given sequence repeatedly until it terminates successfully.
     */
</span><span style="color:#b48ead;">public func </span><span style="color:#bf616a;">retry</span><span style="color:#c0c5ce;">(</span><span style="color:#d08770;">_ </span><span style="color:#bf616a;">maxAttemptCount</span><span style="color:#c0c5ce;">: </span><span style="color:#ebcb8b;">Int</span><span style="color:#c0c5ce;">)
</span></pre>
<p>When an error message reaches this operator, it blocks that error message from propagating down the chain, then retries the previous action again. In the context of Singles, that means executing the closure block once again.</p>
<p>The nice thing about it as any other operator is that we can place it anywhere in the stream (as long as we do it before the <code>subscribe</code> off course), but this is tricky as depending were we put it we get slighly different results, for example we could place it here:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Service.systemSingle
    .do(onError: { error in
        print(&quot;[\(#function)] ❌ request error: \(error)&quot;)
    })
</span><span style="color:#a3be8c;">+   .retry(3)
</span><span style="color:#c0c5ce;">    .subscribe(onSuccess: { globalState in
</span></pre>
<p>3 seems like a nice number, but you can use whatever makes sense to you.
When you tap the refresh button, logs look like this:</p>
<blockquote>
<p><strong>[Service] ❌ request error: unknown</strong>
<strong>[refreshData()] ❌ request error: unknown</strong>
<strong>[Service] ✅ Success</strong></p>
</blockquote>
<p>It fails but then retries and succeeds. (every other request fails, so on the second attempt it always succeeds)</p>
<p>But if you put it before the <code>do</code> like this, the ouput is different:</p>
<pre style="background-color:#2b303b;">
<span style="color:#c0c5ce;">Service.systemSingle
</span><span style="color:#a3be8c;">+   .retry(3)
</span><span style="color:#c0c5ce;">    .do(onError: { error in
        print(&quot;[\(#function)] ❌ request error: \(error)&quot;)
    })
    .subscribe(onSuccess: { globalState in
</span></pre>
<blockquote>
<p><strong>[Service] ❌ request error: unknown</strong>
<strong>[Service] ✅ Success</strong></p>
</blockquote>
<p>What's happening here is that the stream retries 2 more times before letting the error reach the <code>do</code> operator and printing the error inside <code>refreshData()</code>.</p>
<p>We can modify <a href="https://github.com/Julioacarrettoni/playing-with-rxswift/blob/master/003/Before/RxPlaying/Services/Service.swift#L11">this</a> line in  <a href="https://github.com/Julioacarrettoni/playing-with-rxswift/blob/master/003/Before/RxPlaying/Services/Service.swift#L10-L17">overrideNetworkMock()</a> so it always fails:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">var</span><span style="color:#c0c5ce;"> failures = [</span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">]
</span></pre>
<p>And the log now will look like this:</p>
<blockquote>
<p><strong>[Service] ❌ request error: unknown</strong></p>
<p><strong>[Service] ❌ request error: unknown</strong></p>
<p><strong>[Service] ❌ request error: unknown</strong></p>
<p><strong>[refreshData()] ❌ request error: unknown</strong></p>
</blockquote>
<p>As you can see, it runs the entire set of operators up to the <code>retry</code> 3 times before letting the <code>error</code> event go down the chain. </p>
<p>We could even put the <code>.retry(3)</code> higher on the stream, inside the implementation of <a href="https://github.com/Julioacarrettoni/playing-with-rxswift/blob/master/003/Before/RxPlaying/Services/Service.swift#L19"><strong>static</strong> <strong>var</strong> systemSingle: Single&lt;GlobalState&gt;</a>. Again, we have different results if we put it before or after the <code>do</code>.</p>
<p>The placement of the <code>retry</code> is not a trivial decision. It all depends on what is necessary for us to log. Maybe, we want to know of every network request failure, then it should go after the second <code>do</code>. Maybe, we want to track every API network request failure, but we consider failure at the application level only when the retry fails, then it should go in between the 2 <code>do</code>.<br />
Maybe, for us, failures are serious when all the retries fail and not per every single network request; in that case, it should be the very first operator in the chain.</p>
<p>I think this last case is the one that makes more sense for this app, so I'll keep the <code>retry(3)</code> there.</p>
<p>Now we can say that we have considered non-happy paths, but what about edge cases?</p>
<p>There is a nasty one if the user taps on refresh and immediately turns on auto-polling. The app ends up double auto polling because after the manual refresh ends <code>self.isAutoPolling</code> is <code>true</code> and thus fires a new request as if it was auto-polling, but we also have another &quot;thread&quot; doing auto-polling. A quick fix for this is introducing a new argument into our function to differentiate auto-poll from manual refresh:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">private func </span><span style="color:#bf616a;">refreshData</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">autopolling</span><span style="color:#c0c5ce;">: </span><span style="color:#ebcb8b;">Bool</span><span style="color:#c0c5ce;">)
</span></pre><pre style="background-color:#2b303b;">
<span style="color:#b48ead;">if self</span><span style="color:#c0c5ce;">.isAutoPolling &amp;&amp; autopolling {
    </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.refreshData(</span><span style="color:#bf616a;">autopolling</span><span style="color:#c0c5ce;">: autopolling)
}
</span></pre>
<p>And call it with <code>false</code> on the refresh button, but with <code>true</code> on the <code>didSet</code></p>
<p>Now we can say that we have considered edge cases and non-happy paths.</p>
<p> <br />
 <br />
 </p>
<h4 id="pr_req_2">2. Handle errors.</h4>
<p>There is one error to handle, what happens if after 3 retries the manual refresh fails? Currently, nothing, but to be honest, there isn't too much happening when you press the refresh button anyways.</p>
<p>We could show an alert on the <code>onError</code> closure, but that will also show alerts when auto-polling fails, one after the other, that's bad. We can use the <code>autopolling</code> boolean and only show the alert with the boolean is <code>false</code>, but to be honest, this method is getting a little bloated, there's gotta be a better way.</p>
<p>Let's split it in 2 different methods, but if we do that then we have a lot of duplicated code! To avoid that, we can create a private function to hold what's common to each method, and pass the function name so our log keeps showing relevant information:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">private func </span><span style="color:#bf616a;">fetchGlobalState</span><span style="color:#c0c5ce;">(from </span><span style="color:#bf616a;">function</span><span style="color:#c0c5ce;">: </span><span style="color:#ebcb8b;">String</span><span style="color:#c0c5ce;"> = #function) -&gt; </span><span style="color:#ebcb8b;">Single</span><span style="color:#c0c5ce;">&lt;</span><span style="color:#ebcb8b;">GlobalState</span><span style="color:#c0c5ce;">&gt; {
    </span><span style="color:#b48ead;">return </span><span style="color:#ebcb8b;">Service</span><span style="color:#c0c5ce;">.systemSingle
        .</span><span style="color:#d08770;">do</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">onError</span><span style="color:#c0c5ce;">: { error </span><span style="color:#b48ead;">in</span><span style="color:#c0c5ce;">
            print(</span><span style="color:#a3be8c;">&quot;[</span><span style="color:#ab7967;">\(</span><span style="color:#c0c5ce;">function</span><span style="color:#ab7967;">)</span><span style="color:#a3be8c;">] ❌ request error: </span><span style="color:#ab7967;">\(</span><span style="color:#c0c5ce;">error</span><span style="color:#ab7967;">)</span><span style="color:#a3be8c;">&quot;</span><span style="color:#c0c5ce;">)
        })
}
</span></pre>
<p>And then we can use it on our 2 new methods where we only do what is relevant to each and we get to keep the code as simple as possible:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">private func </span><span style="color:#bf616a;">refresh</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.fetchGlobalState()
        .</span><span style="color:#d08770;">subscribe</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">onSuccess</span><span style="color:#c0c5ce;">: { globalState </span><span style="color:#b48ead;">in
            self</span><span style="color:#c0c5ce;">.globalState = globalState
        }, </span><span style="color:#bf616a;">onError</span><span style="color:#c0c5ce;">: { error </span><span style="color:#b48ead;">in
            self</span><span style="color:#c0c5ce;">.showErrorAlert()
        })
        .</span><span style="color:#d08770;">disposed</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">by</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.disposeBag)
}

</span><span style="color:#b48ead;">private func </span><span style="color:#bf616a;">autoPoll</span><span style="color:#c0c5ce;">() {
    </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.fetchGlobalState()
        .</span><span style="color:#d08770;">subscribe</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">onSuccess</span><span style="color:#c0c5ce;">: { globalState </span><span style="color:#b48ead;">in
            self</span><span style="color:#c0c5ce;">.globalState = globalState
            </span><span style="color:#b48ead;">if self</span><span style="color:#c0c5ce;">.isAutoPolling {
                </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.autoPoll()
            }
        }, </span><span style="color:#bf616a;">onError</span><span style="color:#c0c5ce;">: { error </span><span style="color:#b48ead;">in
            if self</span><span style="color:#c0c5ce;">.isAutoPolling {
                </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.autoPoll()
            }
        })
        .</span><span style="color:#d08770;">disposed</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">by</span><span style="color:#c0c5ce;">: </span><span style="color:#b48ead;">self</span><span style="color:#c0c5ce;">.disposeBag)
}
</span></pre>
<p>I'm going to skip all the problems of showing an alert on SwiftUI as <a href="https://www.hackingwithswift.com/about">Paul Hudson</a> already did a great job <a href="https://www.hackingwithswift.com/books/ios-swiftui/showing-alert-messages">here</a>, go and read his fantastic website, subscribe, like, retweet and all of that. You can just go and peek the <code>after</code> project to find it out.</p>
<p> <br />
 <br />
 </p>
<h4 id="pr_req_3">3. Introduces new unit tests.</h4>
<p>Now, we need to ask ourselves &quot;<em>What assumptions are we making?</em>&quot;, in other words, what can be proven catastrophic in the app if it got changed?</p>
<p>Most of our changes are UI related, but there is one change that we made to the behavior of the service that we can test, and that's the <code>retry(3)</code>. Without it, the experience of the app would be significantly degraded. We are going to test that there is a retry mechanism in place. We don't care what it is just as long as when a request fails it gets automatically retried.</p>
<p>Our first test is to make sure the Single gets fired 3 times when the service returns error before failing, so a name for it could be:</p>
<ul>
<li>test + <strong>SystemSingle</strong> + <strong>InternallyRetries3Times</strong> +When + <strong>FailsReturnsError</strong> </li>
</ul>
<p>You can refresh your memory on how we are writing our tests and the naming convention on the previous post in <a href="/post-002#pr_req_3">this section</a>.</p>
<p>We are going to return <code>true</code> always for <code>FakeService.Current.failNext</code> to make sure all requests in this test fail.<br />
We need to ensure that the service call gets retried. One way to do that is to count how many times the <code>FakeService.Current.failNext</code> is gets executed, as this closure runs on every fake network request. We have many options for this, like using a local var and then asserting its value. Given the async nature of the whole business, the best approach is to use <a href="https://developer.apple.com/documentation/xctest/xctestexpectation">XCTestExpectation</a>, and it's properties <a href="https://developer.apple.com/documentation/xctest/xctestexpectation/2806572-expectedfulfillmentcount">expectedFulfillmentCount</a> and <a href="https://developer.apple.com/documentation/xctest/xctestexpectation/2806575-assertforoverfulfill">assertForOverFulfill</a> which names are pretty straight forward.</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> failNextExpectation = </span><span style="color:#ebcb8b;">XCTestExpectation</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">description</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">&quot;FailNext gets executed 3 times&quot;</span><span style="color:#c0c5ce;">)
failNextExpectation.expectedFulfillmentCount = </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">
failNextExpectation.assertForOverFulfill = </span><span style="color:#d08770;">true
</span></pre>
<p>This XCTestExpectation fails the test if at the end the expectation was fulfilled less than 3 times and crashes the test with an exception if they get fulfilled more than 3, a little overreaction if you ask me 😅</p>
<p>We can also use a different <strong>XCTestExpectation</strong> to ensure that the <code>onError:</code> closure on <code>subscribe</code> only gets executed  once:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> onErrorExpectation = </span><span style="color:#ebcb8b;">XCTestExpectation</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">description</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">&quot;We get an error if the request fails&quot;</span><span style="color:#c0c5ce;">)
onErrorExpectation.expectedFulfillmentCount = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">
onErrorExpectation.assertForOverFulfill = </span><span style="color:#d08770;">true
</span></pre>
<p>The whole test now looks like this:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">func </span><span style="color:#bf616a;">testSystemSingleInternallyRetries3TimesWhenFailsReturnsError</span><span style="color:#c0c5ce;">() </span><span style="color:#b48ead;">throws</span><span style="color:#c0c5ce;"> {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> failNextExpectation = </span><span style="color:#ebcb8b;">XCTestExpectation</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">description</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">&quot;FailNext gets executed 3 times&quot;</span><span style="color:#c0c5ce;">)
    failNextExpectation.expectedFulfillmentCount = </span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">
    failNextExpectation.assertForOverFulfill = </span><span style="color:#d08770;">true
    
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> onErrorExpectation = </span><span style="color:#ebcb8b;">XCTestExpectation</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">description</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">&quot;We get an error if the request fails&quot;</span><span style="color:#c0c5ce;">)
    onErrorExpectation.expectedFulfillmentCount = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">
    onErrorExpectation.assertForOverFulfill = </span><span style="color:#d08770;">true
    
    </span><span style="color:#ebcb8b;">FakeService</span><span style="color:#c0c5ce;">.</span><span style="color:#ebcb8b;">Current</span><span style="color:#c0c5ce;">.failNext = {
        failNextExpectation.fulfill()
        </span><span style="color:#b48ead;">return </span><span style="color:#d08770;">true</span><span style="color:#c0c5ce;">
    }
    
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> disposeBag = </span><span style="color:#ebcb8b;">Service</span><span style="color:#c0c5ce;">.systemSingle
        .</span><span style="color:#d08770;">subscribe</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">onSuccess</span><span style="color:#c0c5ce;">: { </span><span style="color:#d08770;">_ </span><span style="color:#b48ead;">in
            </span><span style="color:#ebcb8b;">XCTFail</span><span style="color:#c0c5ce;">(</span><span style="color:#a3be8c;">&quot;We shouldn&#39;t get a result&quot;</span><span style="color:#c0c5ce;">)
        }, </span><span style="color:#bf616a;">onError</span><span style="color:#c0c5ce;">: { </span><span style="color:#d08770;">_ </span><span style="color:#b48ead;">in</span><span style="color:#c0c5ce;">
            onErrorExpectation.fulfill()
        })
    
    </span><span style="color:#ebcb8b;">XCTAssertEqual</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">XCTWaiter</span><span style="color:#c0c5ce;">.wait(</span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;">: [failNextExpectation, onErrorExpectation], </span><span style="color:#bf616a;">timeout</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">0.1</span><span style="color:#c0c5ce;">), .</span><span style="color:#d08770;">completed</span><span style="color:#c0c5ce;">)
    disposeBag.dispose()
}
</span></pre>
<p>As you can see, the test is pretty straightforward to read, and there is no funny business with counters or accumulators.
Now you <strong>should</strong> go ahead and remove the <code>.retry(3)</code> call, or change the number of retries, or change the value returned in <code>FakeService.Current.failNext</code> and verify that the test indeed fails. Don't take my word for it, and don't take yours either. You should always verify your test fails when they are expected to fail, otherwise the test is useless.</p>
<p>The next thing we can test is that the single succeeds if any of the retries succeeds as well. A name for this test can be:</p>
<ul>
<li>test + <strong>SystemSingle</strong> + <strong>Succeeds</strong> + When + <strong>RetrySucceeds</strong></li>
</ul>
<p>For that we need to tweak <code>FakeService.Current.failNext</code> so it only fails the first time, we can do:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">var</span><span style="color:#c0c5ce;"> failNext = </span><span style="color:#d08770;">false
</span><span style="color:#ebcb8b;">FakeService</span><span style="color:#c0c5ce;">.</span><span style="color:#ebcb8b;">Current</span><span style="color:#c0c5ce;">.failNext = {
    failNext.toggle()
    </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> failNext
}
</span></pre>
<p>This new code fails every other request starting with a failure.</p>
<p>For the rest we can use 2 <strong>XCTestExpectation</strong> again, to verify that the success closure is called exactly once and that that <code>FakeService.Current.failNext</code> is called exactly twice. With all of these changes the will look like these:</p>
<pre style="background-color:#2b303b;">
<span style="color:#b48ead;">func </span><span style="color:#bf616a;">testSystemSingleSucceedsWhenRetrySucceeds</span><span style="color:#c0c5ce;">() </span><span style="color:#b48ead;">throws</span><span style="color:#c0c5ce;"> {
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> failNextExpectation = </span><span style="color:#ebcb8b;">XCTestExpectation</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">description</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">&quot;FailNext gets executed 2 times&quot;</span><span style="color:#c0c5ce;">)
    failNextExpectation.expectedFulfillmentCount = </span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">
    failNextExpectation.assertForOverFulfill = </span><span style="color:#d08770;">true
    
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> successExpectation = </span><span style="color:#ebcb8b;">XCTestExpectation</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">description</span><span style="color:#c0c5ce;">: </span><span style="color:#a3be8c;">&quot;We get a success event&quot;</span><span style="color:#c0c5ce;">)
    successExpectation.expectedFulfillmentCount = </span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">
    successExpectation.assertForOverFulfill = </span><span style="color:#d08770;">true
    
    </span><span style="color:#b48ead;">var</span><span style="color:#c0c5ce;"> failNext = </span><span style="color:#d08770;">false
    </span><span style="color:#ebcb8b;">FakeService</span><span style="color:#c0c5ce;">.</span><span style="color:#ebcb8b;">Current</span><span style="color:#c0c5ce;">.failNext = {
        failNextExpectation.fulfill()
        failNext.toggle()
        </span><span style="color:#b48ead;">return</span><span style="color:#c0c5ce;"> failNext
    }
    
    </span><span style="color:#b48ead;">let</span><span style="color:#c0c5ce;"> disposeBag = </span><span style="color:#ebcb8b;">Service</span><span style="color:#c0c5ce;">.systemSingle
        .</span><span style="color:#d08770;">subscribe</span><span style="color:#c0c5ce;">(</span><span style="color:#bf616a;">onSuccess</span><span style="color:#c0c5ce;">: { </span><span style="color:#d08770;">_ </span><span style="color:#b48ead;">in</span><span style="color:#c0c5ce;">
            successExpectation.fulfill()
        }, </span><span style="color:#bf616a;">onError</span><span style="color:#c0c5ce;">: { </span><span style="color:#d08770;">_ </span><span style="color:#b48ead;">in
            </span><span style="color:#ebcb8b;">XCTFail</span><span style="color:#c0c5ce;">(</span><span style="color:#a3be8c;">&quot;It shouldn&#39;t fail.&quot;</span><span style="color:#c0c5ce;">)
        })
    
    </span><span style="color:#ebcb8b;">XCTAssertEqual</span><span style="color:#c0c5ce;">(</span><span style="color:#ebcb8b;">XCTWaiter</span><span style="color:#c0c5ce;">.wait(</span><span style="color:#b48ead;">for</span><span style="color:#c0c5ce;">: [failNextExpectation, successExpectation], </span><span style="color:#bf616a;">timeout</span><span style="color:#c0c5ce;">: </span><span style="color:#d08770;">0.1</span><span style="color:#c0c5ce;">), .</span><span style="color:#d08770;">completed</span><span style="color:#c0c5ce;">)
    disposeBag.dispose()
}
</span></pre>
<p>As I said before, change some numbers, change the retry, do whatever change you deem necessary to verify that the test is working and catching errors.</p>
<p>As you might have discovered if you followed my advice, when an expectation fails it hard to tell which one did, if instead of  <code>XCTAssertEqual(XCTWaiter.wait(for:, timeout:), .completed)</code> we used <code>self.wait(for:, timeout:)</code> tests would fail more gracefully. Sadly there is a bug currently affecting the correctness of this API, it was believed to be fixed recently, but it wasn't.</p>
<p>The bug mostly makes tests way slower on big projects. If the current way fails and you have more than one expectation you can switch temporarily to <code>self.wait(for:, timeout:)</code> to get a better error message or if your project is small and you don't care if it takes a little longer to run the tests just stick with the simpler version. Hopefully, it will be fixed soon 🤞.</p>
<p> <br />
 <br />
 </p>
<table><thead><tr><th></th></tr></thead><tbody>
</tbody></table>
<h1 id="conclusion">Conclusion</h1>
<p>If we look at all the changes we made, our current implementation holds it pretty well. The polling mechanism is still quite weak but is good enough.<br />
We leveraged the power of RxSwift by using the <a href="https://github.com/ReactiveX/RxSwift/blob/c1bd31b397d87a54467af4161dde9d6b27720c19/RxSwift/Traits/PrimitiveSequence.swift#L157">retry</a> operator.<br />
We saw how easy it is to share code between different consumers of the same Single by splitting the method and have one holding the common operator for the others.</p>
<p>We also added some helpful tests to safeguard our code quality.</p>
<p>Now before we open the PR, we should double-check with the designer and see if they have any suggestions… (yes, another cliff hanger)</p>
<p> <br />
 </p>
<table><thead><tr><th></th></tr></thead><tbody>
</tbody></table>
<h5 id="footnotes">Footnotes</h5>
<p><a id='1'>1</a>: If this story hits close to home, please accept my condolences.<br />
<a id='1'>
<a id='2'>2</a></a>: <a href="https://agilemanifesto.org">Agilemanifesto.org</a> &quot;<strong>Responding to change</strong> over following a plan&quot;.</p>

                            </div>
                        </div>
                        
                        
<footer class="card-footer">
    <div class="article-footer">
        <div class="columns is-multiline">
            <div class="column is-12">
                <p>
                    Published
                    

<time datetime="2020-05-03">
    2020-05-03
</time>


                    


                    


                    


                </p>
            </div>
            <div class="column">
                <a class="button is-pulled-right is-info" href="/playing-with-rxswift">Back Home</a>
            </div>
        </div>
    </div>
</footer>

                        
                    </div>
                </article>
            </div>
        </div>
    </section>
</main>

    
    

<footer class="footer js-only">
    <div class="columns">
        <div class="column">
            <div class="content is-flex">
                <div class="theme-select-container">
                    Theme:
                    <select id="theme-select">
                        
                        
                        
                        
                        
                        <option value="default">default</option>
                        
                        
                        
                        
                        
                        
                        <option selected="selected" value="darkly">darkly</option>
                        
                        
                        
                        
                        
                        
                        <option value="flatly">flatly</option>
                        
                        
                        
                        
                        
                        
                        <option value="pulse">pulse</option>
                        
                        
                        
                        
                        
                        
                        <option value="simplex">simplex</option>
                        
                        
                        
                        
                        
                        
                        <option value="lux">lux</option>
                        
                        
                        
                        
                        
                        
                        <option value="slate">slate</option>
                        
                        
                        
                        
                        
                        
                        <option value="solar">solar</option>
                        
                        
                        
                        
                        
                        
                        <option value="superhero">superhero</option>
                        
                        
                    </select>
                </div>
            </div>
        </div>
    </div>
</footer>


    

    <script type="text/javascript" src="https:&#x2F;&#x2F;julioacarrettoni.github.io&#x2F;playing-with-rxswift&#x2F;js&#x2F;zulma_navbar.js"></script>

    
    <script type="text/javascript" src="https:&#x2F;&#x2F;julioacarrettoni.github.io&#x2F;playing-with-rxswift&#x2F;js&#x2F;zulma_search.js"></script>
    

    
</body>

</html>
